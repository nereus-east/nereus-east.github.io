<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>基于redis的延迟、阻塞队列</title>
      <link href="/2020/04/05/ji-yu-redis-de-yan-chi-zu-sai-dui-lie/"/>
      <url>/2020/04/05/ji-yu-redis-de-yan-chi-zu-sai-dui-lie/</url>
      
        <content type="html"><![CDATA[<h2 id="基于redis的延迟、阻塞队列"><a href="#基于redis的延迟、阻塞队列" class="headerlink" title="基于redis的延迟、阻塞队列"></a>基于redis的延迟、阻塞队列</h2><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ol><li>订单 <strong>超时</strong> 未支付，要取消或者提醒用户</li><li>下单未付款，<strong>超过12小时</strong> 则取消订单释放库存</li><li>消费者为保证高可用，收到message后先缓存，消费成功后删除缓存，消费失败则过 <strong>一段时间</strong> 再重试，因为如果基础设施故障，立马重试大概率也是失败的。所以需要延迟</li><li>短信平台设定了 <strong>凌晨0点</strong> 准时发送营销短信</li></ol><h4 id="开发背景以及Q-amp-A"><a href="#开发背景以及Q-amp-A" class="headerlink" title="开发背景以及Q&amp;A"></a>开发背景以及Q&amp;A</h4><ol><li>分布式，J.U.C DelayQueue虽好，可不是分布式的</li><li>避免轮询，减少不必要的开销</li><li>为什么不用Rabbit MQ？不纯粹…就想要一个纯粹的延迟队列</li><li>为什么用Redis？性能好，且有天然的BLPOP这样的天然阻塞命令</li><li>为什么用BRPOPLPUSH？为了保证消息不丢失，高可用</li></ol><h4 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h4><ol><li><strong>延迟</strong><ul><li>通过ZSET中的Score实现，Score设定为期望执行时间，获取到期的任务则很简单，只要获取Score&gt;=当前时间即可</li></ul></li><li><strong>阻塞</strong><ul><li>通过List中的BRPOPLPUSH实现，做到有job立即响应</li></ul></li><li><strong>消息流转</strong><ul><li>结合ZSET + List，同时job元数据存放在hash中，固整个流程如图<br><img src="https://github.com/nereus-east/nereus-sea/blob/master/redis-blocking-delay-queue/%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%BE.jpg?raw=true" alt="消息流转图例"></li></ul></li><li><strong>避免轮询</strong><ul><li>安排一个线程，单独处理搬运（将job从Waiting搬至Ready），每次搬运已经到期的job</li><li>通过wait/notify实现唤醒，服务启动时搬运一次，并peek搬运后Waiting中的队首job，计算wait的时间（即计算下一次搬运的时间）。</li><li>设定类型为AtomicLong的变量nextTransferTime,在put/add job的时候，将job的时间与nextTransferTime比较，如果job的期望时间早于已经记录的nextTransferTime，则通知搬运线程重新wait。</li></ul></li><li><strong>搬运兜底</strong><ul><li>上面说到按需搬运，但是如果最近搬运的线程所在的实例发生了故障怎么办？</li><li>这里我们采用兜底机制，既另起一根线程，每隔1min或者指定的时间，去唤醒搬运线程，这样可以保证最多延迟误差在可控范围之内。</li></ul></li><li><strong>如何消费</strong><ul><li>通过BRPOPLPUSH命令可以实现阻塞，但是每次仅能获取一个job</li><li>这里通过两根线程协同的操作方式，如果获取到一个job，则启用批量获取job的线程，直到批量获取的数量小于预设值，则重新启用BRPOPLPUSH线程。</li></ul></li><li><strong>简化设计</strong> 通过 <strong>双线程消费</strong><ul><li>获取到的job，再批量获取job的Metadata，然后放入内部 BlockingQueue中，用户线程通过BlockingQueue实现阻塞</li></ul></li><li><strong>高可用、重试+超时</strong><ul><li>由于job在消费的同时，会记录在Back中，所以这里要求消费成功后调用complate api，如果消费失败调用retry api。那么问题来了，消费失败了，但是服务挂了也没调用retry怎么办？</li><li>这里再起一根线程，每隔指定的时间去back queue中检查 <strong>队尾</strong> 的job（即right），这里有一个设计技巧，因为back 中的job是BRPOPLPUSH命令入队的，所以设计中可以保证 back 中job的顺序，并且同一个队列中，job都是类似的，所以超时时间也是一样。</li><li>故每次仅需要检查 back中的 right 数据（通过LRANGE命令），如果队尾超时，则下一次多拿出一些right job判定，若还有生命值则放入ZSET同时更新Metadata（使用lua脚本模拟compareAndUpdate，更新成功才放入ZSET，避免重复消费）。否则wait指定间隔。因为是兜底重试，所以频率无需太高。</li></ul></li><li><strong>并发安全</strong><ul><li>上述操作皆通过lua脚本操作，保证操作的原子性</li></ul></li><li><strong>优雅停机</strong><ul><li>a.停止双线程消费 2、停止搬运 3、停止兜底 4、停止retry</li><li>b.停止内部线程池</li><li>c.等待内部队列消费完成，等待指定时间&amp;&amp;内部队列为空</li></ul></li></ol><h4 id="简单图示"><a href="#简单图示" class="headerlink" title="简单图示"></a>简单图示</h4><p><img src="https://github.com/nereus-east/nereus-sea/blob/master/redis-blocking-delay-queue/%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%EF%BC%8C%E6%95%B0%E6%8D%AE%E6%B5%81%E8%BD%AC.jpg?raw=true" alt="数据流转"></p><h4 id="设计优点"><a href="#设计优点" class="headerlink" title="设计优点"></a>设计优点</h4><ol><li>性能好，性能基本上以用户的消费速率决定</li><li>开销不大，避免了轮询</li><li>在分布式的应用下可保证高可用</li></ol><h4 id="设计不足"><a href="#设计不足" class="headerlink" title="设计不足"></a>设计不足</h4><ol><li>支持多实例，但是无法做到多实例平均消费</li><li>Redis集群由于lua脚本的关系，实际上是伪集群（建议仅使用哨兵模式）</li><li>由于redis的持久化策略，无法做到100%的消息不丢失（具体根据redis的持久化策略有关）</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 分布式 </tag>
            
            <tag> Redis </tag>
            
            <tag> 延迟队列 </tag>
            
            <tag> 阻塞队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>响应式编程的由来</title>
      <link href="/2019/04/13/yi-xiang-ying-shi-bian-cheng-de-you-lai/"/>
      <url>/2019/04/13/yi-xiang-ying-shi-bian-cheng-de-you-lai/</url>
      
        <content type="html"><![CDATA[<h1 id="用java示例，理解响应式编程"><a href="#用java示例，理解响应式编程" class="headerlink" title="用java示例，理解响应式编程"></a><center>用java示例，理解响应式编程<center></center></center></h1><p><strong>命令式：同步，阻塞</strong><br><strong>响应式：异步，非阻塞，事件驱动</strong></p><p>首先假设大家都读过java源码，了解过java的各种集合类型的实现<br><strong><em>为了简洁，这里没有显示java8中添加的接口默认实现。</em></strong></p><pre><code class="java">public interface Iterable&lt;T&gt; {    Iterator&lt;T&gt; iterator();}public interface Iterator&lt;E&gt; {    boolean hasNext();    E next();}</code></pre><p>这个接口存在什么问题？如果我需要获取一些数据，那么~~<br>我们不难发现这个是基于 <strong>拉取</strong> 的操作，意思就是好比我们 <strong>主动</strong> 的从数据库当中获取数据。<br>即：我向<code>Iterable</code>发送一个请求，请给我一个<code>Iterator</code>。<br>如果这个时候数据库说：“我正在睡觉呢”，那么我将无穷无尽的等待他睡醒<br>因此：这种操作是会 <strong>阻塞(block)</strong> 的，是 <strong>拉取(pull)</strong> 的，是 <strong>同步(sync)</strong> 的</p><p>同样的，在我们使用迭代器进行循环的时候，是不断的调用<code>Iterator.next()</code>移动到下一条记录，但是这同样会发生 <strong>阻塞</strong> ，如果数据库的数据到底了，那么我就不可能移动到下一条记录，<code>Iterator.next()</code>会发生 <strong>阻塞</strong> ，这个时候系统会说：“嘿嘿，等着吧。just wait for me！”，然后我就傻傻的等着，获取不到任何数据，如果这是在UI线程，那么闯大祸了，整个界面都会卡住，傻傻的提示你“应用程序未响应”。</p><p>现在大神为了解决这样的问题，希望把这样的结构改造的更加合理，beautiful，那么如何改造呢？<br>当然这不是我改造的~改造的作者可能是个数学家也可能是个物理学家，在数学中有一个词汇叫做 <strong>Dual：二元性，二象性</strong>，作者把他称作为： <strong>买一送一</strong>。</p><p>在学物理的时候，我们一定知道欧姆定律：<br>$$I（电流） = \frac{U（电压）}{R（电阻）}$$<br>当我们知道上面这个公式的时候，我们同样可以知道：<br>$$U（电压） = {I（电流）} * {R（电阻）}$$<br>以及<br>$$R（电阻） = \frac{U（电压）}{I（电流）}$$<br>我们只需要知道其中一个公式，就可以很简单的知道其他的公式</p><p>那么接下来的编程将会很容易了，既然我们已经有了一个<code>Iterable</code>，但是不完美，它可能会 <strong>阻塞</strong> 住，所以 <strong>Dual（二元性）</strong> 提示我们，可能有一些不会 <strong>阻塞</strong> 的东西存在</p><p>so<del>~</del>看了一下维基百科上面的介绍：<br><img src="https://github.com/chase-lou/MarkdownPhotos/blob/master/blog/ReactiveExtension/image/ReactiveExtension_Dual.png?raw=true" alt="维基百科-Dual"><br>反向箭头表示 <strong>交换输入和输出</strong> 的位置，并且，为了解决痛点问题，在开口出我们需要做成异步的，接下来，我要开始变形了。</p><p>刚开始我们只是添加一些简单的 <em>void</em> 进去，这是为了之后做铺垫，事实上添加这些void并不改变什么，因为你们知道的，void本来就表示什么都没有，so why don`t you just put <em>void</em> for it，并且 <code>Iterable.iterator()</code> 实际上可以理解为 <code>Iterable.getIterator()</code>，<code>Iterator.next()</code> 也可以理解为 <code>Iterator.getNext()</code></p><pre><code class="java">public interface Iterable&lt;T&gt; {    Iterator&lt;T&gt; getIterator(void);}public interface Iterator&lt;E&gt; {    boolean hasNext(void);    E getNext(void);}</code></pre><p>接下来<code>Iterator.getNext(void)</code> 其实有点不和谐，实际上不但会返回 <code>E</code>，在调用中还可能会throw Exception，但是在开发的时候我们并不知道哪里会抛出异常，java有的时候会要求我们必须将其捕获，所以这段代码可以看成：</p><pre><code class="java">public interface Iterable&lt;T&gt; {    Iterator&lt;T&gt; getIterator(void);}public interface Iterator&lt;E&gt; {    boolean hasNext(void);    E getNext(void) throws Exception;}</code></pre><p>Ok，很好，我们继续，现在有一个IO操作，所以<code>Iterator</code>继承了<code>Closeable</code>接口，这是什么意思呢？意思是当我不想再接收数据的时候。我可以说：“我要关闭掉！”</p><pre><code class="java">public interface Iterable&lt;T&gt; {    Iterator&lt;T&gt; getIterator(void);}public interface Iterator&lt;E&gt; extends Closeable {    boolean hasNext(void);    E getNext(void) throws Exception;}</code></pre><p>当我们调用foreach循环的时候，实际上我们得到的是一个赤裸裸的 <code>Iterator</code>对象<br>但是当我们调用 <code>Iterable.iterator()</code>的时候，我们会获取到两样东西：</p><pre><code class="java">public interface Iterable&lt;T&gt; {    (Closeable &amp; Iterator&lt;T&gt;) getIterator(void);}public interface Iterator&lt;E&gt; extends Closeable{    boolean hasNext(void);    E getNext(void) throws Exception;}</code></pre><p>意思是当我们看见这个对象实现了 <code>Closeable</code>接口的话，我们就有<code>close</code>的能力，同样也拥有了获取更多数据的能力，这样一来我们更加清晰的了解到什么时候应该调用 <code>Iterable.iterator()</code>（这句不是太明白，欢迎去原视频中查看），这就是我们解决问题的方法。</p><p>接下来暂时先不管 <code>Closeable</code> ，它不需要去做任何事情，然后在异步之前我们先看看同步，我们对同步的代码进行 <strong>二元化</strong></p><p>二元化之前：<br><img src="https://github.com/chase-lou/MarkdownPhotos/blob/master/blog/ReactiveExtension/image/ReactiveExtension_Dual_iterator&amp;void_before.png?raw=true" alt="二元化之前"></p><p>二元化之后：<br><img src="https://github.com/chase-lou/MarkdownPhotos/blob/master/blog/ReactiveExtension/image/ReactiveExtension_Dual_iterator&amp;void_after.png?raw=true" alt="二元化之后"></p><p>也就变成了：</p><pre><code class="java">public interface Iterable&lt;T&gt; {    (Closeable &amp; void) getIterator(Iterator&lt;T&gt;);}public interface Iterator&lt;E&gt; extends Closeable{    boolean hasNext(void);    E getNext(void) throws Exception;}</code></pre><p>原来我需要 <strong>主动</strong> 获取数据，而现在不用了，我们 <strong>被动</strong> 的接收他，等待着数据自动到碗里来，原来我拿到数据后可能要自己通过 <code>Iterator</code> 进行 <code>foreach</code> 循环，然后在循环内自己动手操作每一份数据，而现在我只需要将我的操作当做参数传递进去，当有数据过来的时候，他会自动帮我执行我期望的操作。oh!Amazing!我们仅仅是交换了一下输入和输出，就把主动变为了被动!</p><p>接下来我们继续看看 <code>Iterator</code> 接口，<code>Iterator.getNext(void)</code> 这个方法可能会返回一个 <code>E</code> ，但是同时还会返回一个  <code>Exception</code> ，并且这两个输出不是来自同一个地方， 左边返回 <code>E</code> ，而右边返回Exception，这是很古怪的，而函数式编程的输入都在同一边，输出都是在同一边，然后让我们稍微调整一下，让输出都在同一边，当我们进行 <code>Iterator.getNext(void)</code> 操作的时候，我们会得到一个 <code>E</code> 或者一个 <code>Exception</code>:</p><pre><code class="java">public interface Iterable&lt;T&gt; {    Closeable setIterator(Iterator&lt;T&gt;);}public interface Iterator&lt;E&gt; extends Closeable{    boolean hasNext(void);    (E | Exception) getNext(void);}</code></pre><p>让我们继续，如果 <code>Iterator.hasNext(void)</code> 返回了一个 <code>true</code> ，表示我可以继续调用 <code>Iterator.getNext</code> 获取一个 <code>E</code>，果返回给我一个 <code>false</code>，那么我无法获得下一个数据，表示数据已经到了 <strong>结尾</strong>，所以我们还可以继续做一点变换：</p><pre><code class="java">public interface Iterable&lt;T&gt; {    Closeable setIterator(Iterator&lt;T&gt;);}public interface Iterator&lt;E&gt; extends Closeable{    (true | false) hasNext(void);    (E | Exception) getNext(void);}</code></pre><p>接下来，当我调用 <code>Iterator.hasNext(void)</code> 的时候，如果返回值是 <code>true</code> ，我实际上还需要再次调用 <code>Iterator.getNext(void)</code> 获取数据 <code>E</code>，如果返回给我的是 <code>false</code> ，实际上我什么也得不到，所以会返回一个 <code>void</code> ，在调用的过程中可能还会发生异常，返回一个 <code>Exception</code>，让我们把他们合并一下：</p><p><img src="https://github.com/chase-lou/MarkdownPhotos/blob/master/blog/ReactiveExtension/image/ReactiveExtension_Merge_hasNext_getNext.png?raw=true" alt="合并Iterator.hasNext(),Iterator.getNext()"></p><p>然后我们得到了：</p><pre><code class="java">public interface Iterable&lt;T&gt; {    Closeable setIterator(Iterator&lt;T&gt;);}public interface Iterator&lt;E&gt; extends Closeable{    (E | void | Exception) getIfHasNext(void);}</code></pre><p>可能你还不知道为什么要这样操作，其实我们是为了更加方便的 <strong>二元化</strong>：</p><p><img src="https://github.com/chase-lou/MarkdownPhotos/blob/master/blog/ReactiveExtension/image/ReactiveExtension_Dual_iterator_inner_before.png?raw=true" alt="二元化Iterator inner before"></p><p><img src="https://github.com/chase-lou/MarkdownPhotos/blob/master/blog/ReactiveExtension/image/ReactiveExtension_Dual_iterator_inner_after.png?raw=true" alt="二元化Iterator inner after"></p><p>，做了二元化之后，本身应该由我去调用的 <code>Iterator</code> 接口中的方法，也相应的改为由数据拥有者，也就是数据库去调用，而我，只需要舒舒服服躺在沙发上等待着他把数据送到我的面前，当然了，我们不可能在idea 中这样编写java代码，就算写了编译器也不会让我们编译通过的，所以我们把它变得更加java一些，事实上，这三种 <code>|</code> 关系的输入，等价于三个方法，当有数据库有数据时，可以调用 <code>onNext(E)</code> 方法，当出现异常时，调用 <code>onError(Exception)</code> 方法，当没有数据了，调用 <code>onComplete</code> 表示完成。</p><pre><code class="java">public interface Iterable&lt;T&gt; {    Closeable setIterator(Iterator&lt;T&gt;);}public interface Iterator&lt;E&gt;{    void onNext(E);    void onError(Exception);    void onComplete();}</code></pre><p>最后，对应到java的 <code>org.reactivestreams</code> 包中，是下面几个接口：</p><pre><code class="java">public interface Publisher&lt;T&gt; {    void subscribe(Subscriber&lt;? super T&gt; var1);}public interface Subscriber&lt;T&gt; {    void onSubscribe(Subscription var1);    void onNext(T var1);    void onError(Throwable var1);    void onComplete();}public interface Subscription {    void request(long var1);    void cancel();}</code></pre><p>不难发现原来大同小异。</p><p>以上都是我们做的一个小实验，虽然参考事例是基于c#的响应式库，但是设计模式是通用的。最近笔者在学习 <em>Spring WebFlux</em> 以及 <em>Reactor3</em> 中遇到许多问题，还在不断的学习当中，希望广大有兴趣的学习响应式编程的小伙伴可以在这篇文章中发现一点价值。</p><p>那么接下来，谁实现了这些接口呢，在java中分别有<a href="http://reactivex.io/" target="_blank" rel="noopener">RxJava</a>以及<a href="https://projectreactor.io/" target="_blank" rel="noopener">Project Reactor</a>(目前最新版本是3.2.8.RELEASE)，下一篇文章中笔者将会使用Reactor3开发简单的demo，来说明这东西是要如何进行开发的。</p><p>这里感谢翻译<a href="https://github.com/get-set/reactor-core/blob/master-zh/src/docs/index.html" target="_blank" rel="noopener">Reactor3文档</a>的作者：<a href="https://github.com/get-set" target="_blank" rel="noopener">享学IT-刘康</a></p><p>本文参考至来自yangecnu的博客<a href="http://www.cnblogs.com/yangecnu/archive/2012/11/03/Introducting_ReactiveExtensions.html" target="_blank" rel="noopener">Reactive Extensions入门</a>，感谢他的分享</p><p>主要参考：yangecnu翻译的视频<a href="https://v.youku.com/v_show/id_XNDcwMjQ0MTY4.html?x&amp;sharefrom=android&amp;sharekey=ce932eb7d34bf8d50cd4571b37d55a6b9" target="_blank" rel="noopener">Reactive Extension</a></p><p>原版视频地址：<a href="http://channel9.msdn.com/Blogs/codefest/DC2010T0100-Keynote-Rx-curing-your-asynchronous-programming-blues" target="_blank" rel="noopener">DevCamp 2010 Keynote - Rx: Curing your asynchronous programming blues</a></p><p>在他的博客中还有很多其他的参考资料，欢迎大家一起学习</p><p>文章中涉及到的一本书<a href="https://www.amazon.com/Design-Patterns-Object-Oriented-Addison-Wesley-Professional-ebook/dp/B000SEIBB8" target="_blank" rel="noopener">Design Pattern(设计模式)</a>，本文主要运用了观察者模式</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
